module memory::<DATA_WIDTH: u32, ADDR_WIDTH: u32> #(
    param FILEPATH: string = "",
) (
    clk   : input   clock                                     ,
    rst   : input   reset                                     ,
    membus: modport membus_if::<DATA_WIDTH, ADDR_WIDTH>::slave,
) {
    type DataType = logic<DATA_WIDTH>;

    var mem: DataType [2 ** ADDR_WIDTH];

    initial {
        // initialize mem
        if FILEPATH != "" {
            $readmemh(FILEPATH, mem);
        }
    }

    enum State {
        Ready,
        WriteValid,
    }
    var state: State;

    var addr_saved : logic   <ADDR_WIDTH>;
    var wdata_saved: DataType            ;
    var wmask_saved: logic   <DATA_WIDTH>;
    var rdata_saved: DataType            ;

    always_comb {
        membus.ready = state == State::Ready;
    }

    always_ff {
        if state == State::WriteValid {
            mem[addr_saved[ADDR_WIDTH - 1:0]] = wdata_saved & wmask_saved | rdata_saved & ~wmask_saved;
        }
    }

    always_ff {
        if_reset {
            state         = State::Ready;
            membus.rvalid = 0;
            membus.rdata  = 0;
            addr_saved    = 0;
            wdata_saved   = 0;
            wmask_saved   = 0;
            rdata_saved   = 0;
        } else {
            case state {
                State::Ready: {
                    membus.rvalid = membus.valid & !membus.wen;
                    membus.rdata  = mem[membus.addr[ADDR_WIDTH - 1:0]];
                    addr_saved    = membus.addr[ADDR_WIDTH - 1:0];
                    wdata_saved   = membus.wdata;
                    wmask_saved   = membus.wmask_expand();
                    rdata_saved   = mem[membus.addr[ADDR_WIDTH - 1:0]];
                    if membus.valid && membus.wen {
                        state = State::WriteValid;
                    }
                }
                State::WriteValid: {
                    state         = State::Ready;
                    membus.rvalid = 1;
                }
            }
        }
    }
}
