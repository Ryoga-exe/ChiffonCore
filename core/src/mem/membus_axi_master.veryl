module membus_axi_master #(
    param AXI_ID_W  : u32 = 1 ,
    param AXI_ADDR_W: u32 = 32,
    param AXI_DATA_W: u32 = 64,

    param DATA_WIDTH: u32 = 64,
    param ADDR_WIDTH: u32 = 32, // NOTE: consider
) (
    clk: input clock,
    rst: input reset,

    run: input logic,

    dram_base: input logic<32>,
    entry_pc : input logic<32>,

    // membus (plain wires; matches membus_if)
    mem_valid : input  logic                ,
    mem_ready : output logic                ,
    mem_addr  : input  logic<ADDR_WIDTH>    ,
    mem_wen   : input  logic                ,
    mem_wdata : input  logic<DATA_WIDTH>    ,
    mem_wmask : input  logic<DATA_WIDTH / 8>,
    mem_rvalid: output logic                ,
    mem_rdata : output logic<DATA_WIDTH>    ,

    // AXI Write Address
    M_AXI_AWID   : output logic<AXI_ID_W>  ,
    M_AXI_AWADDR : output logic<AXI_ADDR_W>,
    M_AXI_AWLEN  : output logic<8>         ,
    M_AXI_AWSIZE : output logic<3>         ,
    M_AXI_AWBURST: output logic<2>         ,
    M_AXI_AWLOCK : output logic<2>         ,
    M_AXI_AWCACHE: output logic<4>         ,
    M_AXI_AWPROT : output logic<3>         ,
    M_AXI_AWQOS  : output logic<4>         ,
    M_AXI_AWVALID: output logic            ,
    M_AXI_AWREADY: input  logic            ,

    // AXI Write Data
    M_AXI_WDATA : output logic<AXI_DATA_W>      ,
    M_AXI_WSTRB : output logic<(AXI_DATA_W / 8)>,
    M_AXI_WLAST : output logic                  ,
    M_AXI_WVALID: output logic                  ,
    M_AXI_WREADY: input  logic                  ,

    // --------------- AXI Write Response ----------------
    M_AXI_BID   : input  logic<AXI_ID_W>,
    M_AXI_BRESP : input  logic<2>       ,
    M_AXI_BVALID: input  logic          ,
    M_AXI_BREADY: output logic          ,

    // AXI Read Address
    M_AXI_ARID   : output logic<AXI_ID_W>  ,
    M_AXI_ARADDR : output logic<AXI_ADDR_W>,
    M_AXI_ARLEN  : output logic<8>         ,
    M_AXI_ARSIZE : output logic<3>         ,
    M_AXI_ARBURST: output logic<2>         ,
    M_AXI_ARLOCK : output logic<2>         ,
    M_AXI_ARCACHE: output logic<4>         ,
    M_AXI_ARPROT : output logic<3>         ,
    M_AXI_ARQOS  : output logic<4>         ,
    M_AXI_ARVALID: output logic            ,
    M_AXI_ARREADY: input  logic            ,

    // AXI Read Data
    M_AXI_RID   : input  logic<AXI_ID_W>  ,
    M_AXI_RDATA : input  logic<AXI_DATA_W>,
    M_AXI_RRESP : input  logic<2>         ,
    M_AXI_RLAST : input  logic            ,
    M_AXI_RVALID: input  logic            ,
    M_AXI_RREADY: output logic            ,

    // debug
    last_pc: output logic<32>,
) {
    enum State {
        Idle,
        Ar,
        R,
        Aw,
        W,
        B,
    }
    var state     : State                ;
    var pend_addr : logic<ADDR_WIDTH>    ;
    var pend_wdata: logic<DATA_WIDTH>    ;
    var pend_wmask: logic<DATA_WIDTH / 8>;
    var pend_wen  : logic                ;

    // Accept next request only when idle
    assign mem_ready = run && (state == State::Idle);

    always_ff {
        if_reset {
            state      = State::Idle;
            pend_addr  = 0;
            pend_wdata = 0;
            pend_wmask = 0;
            pend_wen   = 0;

            mem_rvalid = 0;
            mem_rdata  = 0;
            last_pc    = 0;
        } else {
            mem_rvalid = 1'b0; // 1-cycle pulse

            case state {
                State::Idle: {
                    if mem_valid && mem_ready {
                        pend_addr  = mem_addr;
                        pend_wdata = mem_wdata;
                        pend_wmask = mem_wmask;
                        pend_wen   = mem_wen;
                        last_pc    = mem_addr;

                        state = if mem_wen ? State::Aw : State::Ar;
                    }
                }
                // ---------- Read ----------
                State::Ar: {
                    if M_AXI_ARREADY {
                        state = State::R;
                    }
                }
                State::R: {
                    if M_AXI_RVALID {
                        mem_rdata  = M_AXI_RDATA[DATA_WIDTH - 1:0];
                        mem_rvalid = 1'b1;
                        state      = State::Idle;
                    }
                }
                // ---------- Write ----------
                State::Aw: {
                    if M_AXI_AWREADY {
                        state = State::W;
                    }
                }
                State::W: {
                    if M_AXI_WREADY {
                        state = State::B;
                    }
                }
                State::B: {
                    if M_AXI_BVALID {
                        // store completion pulse (no rdata)
                        mem_rvalid = 1'b1;
                        state      = State::Idle;
                    }
                }
                default: {
                    state = State::Idle;
                }
            }
        }
    }

    let axi_addr: logic<AXI_ADDR_W> = (dram_base + entry_pc + pend_addr) & 32'hFFFF_FFF8;

    always_comb {
        // defaults
        M_AXI_ARVALID = 1'b0;
        M_AXI_ARADDR  = 0;
        M_AXI_ARLEN   = 8'd0;
        M_AXI_ARSIZE  = 3'd3; // 8 bytes
        M_AXI_ARBURST = 2'b01; // INCR
        M_AXI_ARLOCK  = 2'b00;
        M_AXI_ARCACHE = 4'b0000;
        M_AXI_ARPROT  = 3'b000;
        M_AXI_ARQOS   = 4'b0000;
        M_AXI_ARID    = {1'b0 repeat AXI_ID_W};

        M_AXI_RREADY = 1'0;

        M_AXI_AWVALID = 1'b0;
        M_AXI_AWADDR  = 0;
        M_AXI_AWLEN   = 8'd0;
        M_AXI_AWSIZE  = 3'd3; // 8 bytes
        M_AXI_AWBURST = 2'b01; // INCR
        M_AXI_AWLOCK  = 2'b00;
        M_AXI_AWCACHE = 4'b0000;
        M_AXI_AWPROT  = 3'b000;
        M_AXI_AWQOS   = 4'b0000;
        M_AXI_AWID    = {1'b0 repeat AXI_ID_W};

        M_AXI_WVALID = 1'b0;
        M_AXI_WDATA  = 0;
        M_AXI_WSTRB  = {1'b1 repeat (AXI_DATA_W / 8)}; // word store only (SW) for now
        M_AXI_WLAST  = 1'b1;

        M_AXI_BREADY = 1'b0;

        // active behavior
        if run {
            if state == State::Ar {
                M_AXI_ARVALID = 1'b1;
                M_AXI_ARADDR  = axi_addr;
            }
            if state == State::R {
                M_AXI_RREADY = 1'b1;
            }

            if state == State::Aw {
                M_AXI_AWVALID = 1'b1;
                M_AXI_AWADDR  = axi_addr;
            }
            if state == State::W {
                M_AXI_WVALID = 1'b1;
                M_AXI_WDATA  = pend_wdata;
                M_AXI_WSTRB  = pend_wmask;
            }
            if state == State::B {
                M_AXI_BREADY = 1'b1;
            }
        }
    }
}
