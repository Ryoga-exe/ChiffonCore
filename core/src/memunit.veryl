import eei::*;
import corectrl::*;

/// Module that performs memory operations
module memunit (
    clk   : input   clock         ,
    rst   : input   reset         ,
    valid : input   logic         ,
    is_new: input   logic         , // Whether a new instruction is supplied
    ctrl  : input   InstCtrl      , // InstCtrl of the instruction
    addr  : input   Addr          , // Address to access
    rs2   : input   UIntX         , // Data to write for store instruction
    rdata : output  UIntX         , // Load instruction result (valid when stall == 0)
    stall : output  logic         , // Memory access instruction not completed
    membus: modport Membus::master, // Interface with memory
) {
    enum State: logic<2> {
        Init, // accepts commands
        WaitReady, // waiting for memory to become operable
        WaitValid, // waiting for memory operation to complete
    }
    var state: State;

    var req_wen  : logic                       ;
    var req_addr : Addr                        ;
    var req_wdata: logic<MEMBUS_DATA_WIDTH>    ;
    var req_wmask: logic<MEMBUS_DATA_WIDTH / 8>;

    const W   : u32                      = XLEN;
    let D   : logic<MEMBUS_DATA_WIDTH> = membus.rdata;
    let sext: logic                    = (ctrl.funct3[2] == 1'b0); // Whether to perform sign extension

    always_comb {
        // memory access
        membus.valid = (state == State::WaitReady);
        membus.addr  = req_addr;
        membus.wen   = req_wen;
        membus.wdata = req_wdata;
        membus.wmask = req_wmask;

        // result of load
        rdata = case ctrl.funct3[1:0] {
            2'b00: case addr[2:0] {
                0      : {sext & D[7] repeat W - 8, D[7:0]},
                1      : {sext & D[15] repeat W - 8, D[15:8]},
                2      : {sext & D[23] repeat W - 8, D[23:16]},
                3      : {sext & D[31] repeat W - 8, D[31:24]},
                4      : {sext & D[39] repeat W - 8, D[39:32]},
                5      : {sext & D[47] repeat W - 8, D[47:40]},
                6      : {sext & D[55] repeat W - 8, D[55:48]},
                7      : {sext & D[63] repeat W - 8, D[63:56]},
                default: 'x,
            },
            2'b01: case addr[2:0] {
                0      : {sext & D[15] repeat W - 16, D[15:0]},
                2      : {sext & D[31] repeat W - 16, D[31:16]},
                4      : {sext & D[47] repeat W - 16, D[47:32]},
                6      : {sext & D[63] repeat W - 16, D[63:48]},
                default: 'x,
            },
            2'b10: case addr[2:0] {
                0      : {sext & D[31] repeat W - 32, D[31:0]},
                4      : {sext & D[63] repeat W - 32, D[63:32]},
                default: 'x,
            },
            2'b11  : D,
            default: 'x,
        };
        stall = valid & case state {
            State::Init     : is_new && inst_is_memop(ctrl),
            State::WaitReady: 1,
            State::WaitValid: !membus.rvalid,
            default         : 0,
        };
    }

    always_ff {
        if_reset {
            state     = State::Init;
            req_wen   = 0;
            req_addr  = 0;
            req_wdata = 0;
            req_wmask = 0;
        } else {
            if !valid {
                state = State::Init;
            } else {
                case state {
                    State::Init: if is_new & inst_is_memop(ctrl) {
                        state     = State::WaitReady;
                        req_wen   = inst_is_store(ctrl);
                        req_addr  = addr;
                        req_wdata = rs2 << {addr[2:0], 3'b0};
                        req_wmask = case ctrl.funct3[1:0] {
                            2'b00: 8'b1 << addr[2:0], // SB
                            2'b01: case addr[2:0] { // SH
                                6      : 8'b11000000,
                                4      : 8'b00110000,
                                2      : 8'b00001100,
                                0      : 8'b00000011,
                                default: 'x,
                            },
                            2'b10: case addr[2:0] { // SW
                                0      : 8'b00001111,
                                4      : 8'b11110000,
                                default: 'x,
                            },
                            2'b11  : 8'b11111111, // SD
                            default: 'x,
                        };
                    }
                    State::WaitReady: if membus.ready {
                        state = State::WaitValid;
                    }
                    State::WaitValid: if membus.rvalid {
                        state = State::Init;
                    }
                    default: {}
                }
            }
        }
    }
}
