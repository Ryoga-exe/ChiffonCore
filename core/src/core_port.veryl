/// core_port
/// Wrapper around `core` that exposes membus as plain signals.
/// This lets a Verilog top (top.v) instantiate the CPU without using SV interfaces in the top.
import eei::*;

module core_port #(
    param ROM_FILEPATH: string = "bootrom.hex",
) (
    clk: input clock,
    rst: input reset,

    ram_membus_valid : output logic                    ,
    ram_membus_ready : input  logic                    ,
    ram_membus_addr  : output logic<32>                , // NOTE: consider: use RAM_ADDR_WIDTH (but 20)
    ram_membus_wen   : output logic                    ,
    ram_membus_wdata : output logic<RAM_DATA_WIDTH>    ,
    ram_membus_wmask : output logic<RAM_DATA_WIDTH / 8>,
    ram_membus_rvalid: input  logic                    ,
    ram_membus_rdata : input  logic<RAM_DATA_WIDTH>    ,

    uart_rxd: input  logic,
    uart_txd: output logic,

    // CPU -> peripheral regbus (display/draw)
    periph_wraddr: output logic<16>,
    periph_byteen: output logic<4> ,
    periph_wren  : output logic    ,
    periph_wdata : output logic<32>,
    periph_rdaddr: output logic<16>,
    periph_rden  : output logic    ,
    periph_rdata : input  logic<32>,

    led: output UIntX,
) {
    inst mmio_membus       : Membus;
    inst mmio_ram_membus   : Membus;
    inst mmio_rom_membus   : Membus;
    inst mmio_aclint_membus: Membus;
    inst mmio_uart_membus  : Membus;
    inst mmio_regbus_membus: Membus;

    inst rom_membus     : membus_if::<ROM_DATA_WIDTH, ROM_ADDR_WIDTH>;
    inst aclint_core_bus: aclint_if;

    // for instruction fetch
    inst i_membus     : Membus;
    inst i_membus_core: core_inst_if;
    // for load/store
    inst d_membus     : Membus;
    inst d_membus_core: core_data_if;

    var memarb_last_i: logic;

    // Arbitrate memory access to mmio_controller
    always_ff {
        if_reset {
            memarb_last_i = 0;
        } else {
            if mmio_membus.ready {
                memarb_last_i = !d_membus.valid;
            }
        }
    }

    // core drives: bus.valid/addr/wen/wdata
    // outside drives: bus.ready/rvalid/rdata
    always_comb {
        i_membus.ready  = mmio_membus.ready && !d_membus.valid;
        i_membus.rvalid = mmio_membus.rvalid && memarb_last_i;
        i_membus.rdata  = mmio_membus.rdata;

        d_membus.ready  = mmio_membus.ready;
        d_membus.rvalid = mmio_membus.rvalid && !memarb_last_i;
        d_membus.rdata  = mmio_membus.rdata;

        mmio_membus.valid = i_membus.valid | d_membus.valid;

        if d_membus.valid {
            mmio_membus.addr  = d_membus.addr;
            mmio_membus.wen   = d_membus.wen;
            mmio_membus.wdata = d_membus.wdata;
            mmio_membus.wmask = d_membus.wmask;
        } else {
            mmio_membus.addr  = i_membus.addr;
            mmio_membus.wen   = 0; // fetch always
            mmio_membus.wdata = 'x;
            mmio_membus.wmask = 'x;
        }
    }

    always_comb {
        // mmio <> RAM
        ram_membus_valid       = mmio_ram_membus.valid;
        mmio_ram_membus.ready  = ram_membus_ready;
        ram_membus_addr        = mmio_ram_membus.addr;
        ram_membus_wen         = mmio_ram_membus.wen;
        ram_membus_wdata       = mmio_ram_membus.wdata;
        ram_membus_wmask       = mmio_ram_membus.wmask;
        mmio_ram_membus.rvalid = ram_membus_rvalid;
        mmio_ram_membus.rdata  = ram_membus_rdata;
    }

    // Converts the address to a data unit address
    function addr_to_memaddr::<DATA_WIDTH: u32, ADDR_WIDTH: u32> (
        addr: input logic<XLEN>,
    ) -> logic<ADDR_WIDTH> {
        return addr[$clog2(DATA_WIDTH / 8)+:ADDR_WIDTH];
    }

    always_comb {
        // mmio <> ROM
        rom_membus.valid       = mmio_rom_membus.valid;
        mmio_rom_membus.ready  = rom_membus.ready;
        rom_membus.addr        = addr_to_memaddr::<ROM_DATA_WIDTH, ROM_ADDR_WIDTH>(mmio_rom_membus.addr);
        rom_membus.wen         = 0;
        rom_membus.wdata       = 0;
        rom_membus.wmask       = 0;
        mmio_rom_membus.rvalid = rom_membus.rvalid;
        mmio_rom_membus.rdata  = rom_membus.rdata;
    }

    inst rom: memory::<ROM_DATA_WIDTH, ROM_ADDR_WIDTH> #(
        FILEPATH: ROM_FILEPATH,
    ) (
        clk               ,
        rst               ,
        membus: rom_membus,
    );

    // ACLINT
    inst aclintm: aclint_memory (
        clk                       ,
        rst                       ,
        membus: mmio_aclint_membus,
        aclint: aclint_core_bus   ,
    );

    // UART MMIO (16550-like)
    inst uart0: uart_mmio #(
        CLOCK_FREQUENCY: 125_000_000,
        BAUD_RATE      : 115200     ,
    ) (
        clk                     ,
        rst                     ,
        rxd   : uart_rxd        ,
        txd   : uart_txd        ,
        membus: mmio_uart_membus,
    );

    // REGBUS MMIO bridge (CPU MMIO -> regbus signals)
    inst regbus0: regbus_mmio (
        clk                       ,
        rst                       ,
        membus: mmio_regbus_membus,
        WRADDR: periph_wraddr     ,
        BYTEEN: periph_byteen     ,
        WREN  : periph_wren       ,
        WDATA : periph_wdata      ,
        RDADDR: periph_rdaddr     ,
        RDEN  : periph_rden       ,
        RDATA : periph_rdata      ,
    );

    inst mmioc: mmio_controller (
        clk                              ,
        rst                              ,
        req_core     : mmio_membus       ,
        ram_membus   : mmio_ram_membus   ,
        rom_membus   : mmio_rom_membus   ,
        aclint_membus: mmio_aclint_membus,
        uart_membus  : mmio_uart_membus  ,
        regbus_membus: mmio_regbus_membus,
    );

    inst amou: amounit (
        clk                  ,
        rst                  ,
        slave : d_membus_core,
        master: d_membus     ,
    );

    inst fetcher: inst_fetcher (
        clk                   ,
        rst                   ,
        core_if: i_membus_core,
        mem_if : i_membus     ,
    );

    inst u_core: core (
        clk                      ,
        rst                      ,
        i_membus: i_membus_core  ,
        d_membus: d_membus_core  ,
        aclint  : aclint_core_bus,
        led                      ,
    );
}
