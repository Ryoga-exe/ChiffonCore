/// core_port
/// Wrapper around `core` that exposes membus as plain signals.
/// This lets a Verilog top (top.v) instantiate the CPU without using SV interfaces in the top.
import eei::*;

module core_port (
    clk: input clock,
    rst: input reset,

    ram_membus_valid : output logic                    ,
    ram_membus_ready : input  logic                    ,
    ram_membus_addr  : output logic<32>                , // NOTE: consider: use RAM_ADDR_WIDTH (but 20)
    ram_membus_wen   : output logic                    ,
    ram_membus_wdata : output logic<RAM_DATA_WIDTH>    ,
    ram_membus_wmask : output logic<RAM_DATA_WIDTH / 8>,
    ram_membus_rvalid: input  logic                    ,
    ram_membus_rdata : input  logic<RAM_DATA_WIDTH>    ,

    led: output UIntX,
) {
    inst mmio_membus    : Membus;
    inst mmio_ram_membus: Membus;

    inst i_membus: membus_if::<ILEN, XLEN>; // for instruction fetch
    inst d_membus: Membus; // for load/store

    var memarb_last_i    : logic;
    var memarb_last_iaddr: Addr ;

    // Arbitrate memory access to mmio_controller
    always_ff {
        if_reset {
            memarb_last_i     = 0;
            memarb_last_iaddr = 0;
        } else {
            if mmio_membus.ready {
                memarb_last_i     = !d_membus.valid;
                memarb_last_iaddr = i_membus.addr;
            }
        }
    }

    // NOTE: consider
    // アドレスをデータ単位でのアドレスに変換する (必要？)
    function addr_to_memaddr::<DATA_WIDTH: u32, ADDR_WIDTH: u32> (
        addr: input logic<XLEN>,
    ) -> logic<ADDR_WIDTH> {
        return addr[$clog2(DATA_WIDTH / 8)+:ADDR_WIDTH];
    }

    // core drives: bus.valid/addr/wen/wdata
    // outside drives: bus.ready/rvalid/rdata
    always_comb {
        i_membus.ready  = mmio_membus.ready && !d_membus.valid;
        i_membus.rvalid = mmio_membus.rvalid && memarb_last_i;
        i_membus.rdata  = if memarb_last_iaddr[2] == 0 ? mmio_membus.rdata[31:0] : mmio_membus.rdata[63:32];

        d_membus.ready  = mmio_membus.ready;
        d_membus.rvalid = mmio_membus.rvalid && !memarb_last_i;
        d_membus.rdata  = mmio_membus.rdata;

        mmio_membus.valid = i_membus.valid | d_membus.valid;

        if d_membus.valid {
            mmio_membus.addr  = d_membus.addr;
            mmio_membus.wen   = d_membus.wen;
            mmio_membus.wdata = d_membus.wdata;
            mmio_membus.wmask = d_membus.wmask;
        } else {
            mmio_membus.addr  = i_membus.addr;
            mmio_membus.wen   = 0; // fetch always
            mmio_membus.wdata = 'x;
            mmio_membus.wmask = 'x;
        }
    }

    always_comb {
        // mmio <> RAM
        ram_membus_valid       = mmio_ram_membus.valid;
        mmio_ram_membus.ready  = ram_membus_ready;
        ram_membus_addr        = mmio_ram_membus.addr; // NOTE: should I use: addr_to_memaddr::<RAM_DATA_WIDTH, RAM_ADDR_WIDTH>(mmio_ram_membus.addr); ?
        ram_membus_wen         = mmio_ram_membus.wen;
        ram_membus_wdata       = mmio_ram_membus.wdata;
        ram_membus_wmask       = mmio_ram_membus.wmask;
        mmio_ram_membus.rvalid = ram_membus_rvalid;
        mmio_ram_membus.rdata  = ram_membus_rdata;
    }

    inst mmioc: mmio_controller (
        clk                        ,
        rst                        ,
        req_core  : mmio_membus    ,
        ram_membus: mmio_ram_membus,
    );

    inst u_core: core (
        clk       ,
        rst       ,
        i_membus  ,
        d_membus  ,
        led       ,
    );
}
