import eei::*;

module mmio_controller (
    clk       : input   clock         ,
    rst       : input   reset         ,
    req_core  : modport Membus::slave ,
    ram_membus: modport Membus::master,
    rom_membus: modport Membus::master,
) {

    enum Device {
        UNKNOWN,
        RAM,
        ROM,
    }

    inst req_saved: Membus;

    var last_device : Device;
    var is_requested: logic ;

    // reset master with 0
    function reset_membus_master (
        master: modport Membus::master_output,
    ) {
        master.valid = 0;
        master.addr  = 0;
        master.wen   = 0;
        master.wdata = 0;
        master.wmask = 0;
    }

    // Reset all device's master
    function reset_all_device_masters () {
        reset_membus_master(ram_membus);
        reset_membus_master(rom_membus);
    }

    // Get device from address
    function get_device (
        addr: input Addr,
    ) -> Device {
        if MMAP_ROM_BEGIN <= addr && addr <= MMAP_ROM_END {
            return Device::ROM;
        }
        if addr >= MMAP_RAM_BEGIN {
            return Device::RAM;
        }
        return Device::UNKNOWN;
    }

    // Assign req information to the device's master
    function assign_device_master (
        req: modport Membus::all_input,
    ) {
        case get_device(req.addr) {
            Device::RAM: {
                ram_membus      <> req;
                ram_membus.addr -= MMAP_RAM_BEGIN;
            }
            Device::ROM: {
                rom_membus      <> req;
                rom_membus.addr -= MMAP_ROM_BEGIN;
            }
            default: {}
        }
    }

    // Assign device rvalid and rdata to req
    function assign_device_slave (
        device: input   Device          ,
        req   : modport Membus::response,
    ) {
        req.rvalid = 1;
        req.rdata  = 0;
        case device {
            Device::RAM: req <> ram_membus;
            Device::ROM: req <> rom_membus;
            default    : {}
        }
    }

    // Get device ready information
    function get_device_ready (
        device: input Device,
    ) -> logic {
        case device {
            Device::RAM: return ram_membus.ready;
            Device::ROM: return rom_membus.ready;
            default    : {}
        }
    }

    // Get device's rvalid
    function get_device_rvalid (
        device: input Device,
    ) -> logic {
        case device {
            Device::RAM: return ram_membus.rvalid;
            Device::ROM: return rom_membus.rvalid;
            default    : {}
        }
        return 1;
    }

    // Assign req_core
    always_comb {
        // default value
        req_core.ready  = 0;
        req_core.rvalid = 0;
        req_core.rdata  = 0;

        if req_saved.valid {
            if is_requested {
                // return result
                assign_device_slave(last_device, req_core);
                req_core.ready      = get_device_rvalid(last_device);
            }
        } else {
            req_core.ready = 1;
        }
    }

    // Assign device's master
    always_comb {
        reset_all_device_masters();

        if req_saved.valid {
            if is_requested {
                if get_device_rvalid(last_device) {
                    // Accept new request
                    if req_core.ready && req_core.valid {
                        assign_device_master(req_core);
                    }
                }
            } else {
                // Assign req_saved to device
                assign_device_master(req_saved);
            }
        } else {
            // Accept new request
            if req_core.ready && req_core.valid {
                assign_device_master(req_core);
            }
        }
    }

    // Accept new request
    function accept_request () {
        req_saved.valid = req_core.ready && req_core.valid;
        if req_core.ready && req_core.valid {
            last_device  = get_device(req_core.addr);
            is_requested = get_device_ready(last_device);
            // save req
            req_saved.addr  = req_core.addr;
            req_saved.wen   = req_core.wen;
            req_saved.wdata = req_core.wdata;
            req_saved.wmask = req_core.wmask;
        }
    }

    function on_clock () {
        if req_saved.valid {
            if is_requested {
                if get_device_rvalid(last_device) {
                    accept_request();
                }
            } else {
                is_requested = get_device_ready(last_device);
            }
        } else {
            accept_request();
        }
    }

    function on_reset () {
        last_device         = Device::UNKNOWN;
        is_requested        = 0;
        reset_membus_master(req_saved);
    }

    always_ff {
        if_reset {
            on_reset();
        } else {
            on_clock();
        }
    }
}
