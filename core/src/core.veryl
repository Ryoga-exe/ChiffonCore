import eei::*;
import corectrl::*;

module core (
    clk     : input   clock                                    ,
    rst     : input   reset                                    ,
    i_membus: modport membus_if::<ILEN, XLEN>::master          ,
    d_membus: modport membus_if::<MEM_DATA_WIDTH, XLEN>::master,
) {
    // ====================================================
    // * FIFO
    // ====================================================

    // IF -> ID
    struct if_fifo_type {
        addr: Addr,
        bits: Inst,
    }

    // ID -> EX
    struct exq_type {
        addr: Addr    ,
        bits: Inst    ,
        ctrl: InstCtrl,
        imm : UIntX   ,
    }

    // EX -> MEM
    struct memq_type {
        addr      : Addr       ,
        bits      : Inst       ,
        ctrl      : InstCtrl   ,
        imm       : UIntX      ,
        alu_result: UIntX      ,
        rs1_addr  : logic   <5>,
        rs1_data  : UIntX      ,
        rs2_data  : UIntX      ,
        br_taken  : logic      ,
        jump_addr : Addr       ,
    }

    // MEM -> WB
    struct wbq_type {
        addr      : Addr    ,
        bits      : Inst    ,
        ctrl      : InstCtrl,
        imm       : UIntX   ,
        alu_result: UIntX   ,
        mem_rdata : UIntX   ,
        csr_rdata : UIntX   ,
    }

    // IF -> ID
    var if_fifo_wready    : logic       ;
    var if_fifo_wready_two: logic       ;
    var if_fifo_wvalid    : logic       ;
    var if_fifo_wdata     : if_fifo_type;
    var if_fifo_rready    : logic       ;
    var if_fifo_rvalid    : logic       ;
    var if_fifo_rdata     : if_fifo_type;
    // ID -> EX
    var exq_wready: logic   ;
    var exq_wvalid: logic   ;
    var exq_wdata : exq_type;
    var exq_rready: logic   ;
    var exq_rvalid: logic   ;
    var exq_rdata : exq_type;
    // EX -> MEM
    var memq_wready: logic    ;
    var memq_wvalid: logic    ;
    var memq_wdata : memq_type;
    var memq_rready: logic    ;
    var memq_rvalid: logic    ;
    var memq_rdata : memq_type;
    // MEM -> WB
    var wbq_wready: logic   ;
    var wbq_wvalid: logic   ;
    var wbq_wdata : wbq_type;
    var wbq_rready: logic   ;
    var wbq_rvalid: logic   ;
    var wbq_rdata : wbq_type;

    inst if_fifo: fifo #(
        DATA_TYPE: if_fifo_type,
        WIDTH    : 3           ,
    ) (
        clk                           ,
        rst                           ,
        flush     : control_hazard    ,
        wready    : if_fifo_wready    ,
        wready_two: if_fifo_wready_two,
        wvalid    : if_fifo_wvalid    ,
        wdata     : if_fifo_wdata     ,
        rready    : if_fifo_rready    ,
        rvalid    : if_fifo_rvalid    ,
        rdata     : if_fifo_rdata     ,
    );

    inst id_ex_fifo: fifo #(
        DATA_TYPE: exq_type,
        WIDTH    : 1       ,
    ) (
        clk                   ,
        rst                   ,
        flush : control_hazard,
        wready: exq_wready    ,
        wvalid: exq_wvalid    ,
        wdata : exq_wdata     ,
        rready: exq_rready    ,
        rvalid: exq_rvalid    ,
        rdata : exq_rdata     ,
    );
    inst ex_mem_fifo: fifo #(
        DATA_TYPE: memq_type,
        WIDTH    : 1        ,
    ) (
        clk                   ,
        rst                   ,
        flush : control_hazard,
        wready: memq_wready   ,
        wvalid: memq_wvalid   ,
        wdata : memq_wdata    ,
        rready: memq_rready   ,
        rvalid: memq_rvalid   ,
        rdata : memq_rdata    ,
    );
    inst mem_wb_fifo: fifo #(
        DATA_TYPE: wbq_type,
        WIDTH    : 1       ,
    ) (
        clk               ,
        rst               ,
        flush : 0         ,
        wready: wbq_wready,
        wvalid: wbq_wvalid,
        wdata : wbq_wdata ,
        rready: wbq_rready,
        rvalid: wbq_rvalid,
        rdata : wbq_rdata ,
    );

    always_ff {
        if_reset {
            if_fifo_wvalid = 0;
            if_fifo_wdata  = 0;
        } else {
            if control_hazard {
                if_fifo_wvalid = 0;
            } else {
                if if_is_requested && i_membus.rvalid {
                    if_fifo_wvalid     = 1;
                    if_fifo_wdata.addr = if_pc_requested;
                    if_fifo_wdata.bits = i_membus.rdata;
                } else {
                    if if_fifo_wvalid && if_fifo_wready {
                        // FIFO にデータを格納できる
                        if_fifo_wvalid = 0;
                    }
                }
            }
        }
    }

    // ====================================================
    // * Instruction Fetch
    // ====================================================
    var if_pc          : Addr ; // program counter
    var if_is_requested: logic; // fetch 中か
    var if_pc_requested: Addr ; // 要求アドレス

    let if_pc_next: Addr = if_pc + 4;

    var control_hazard        : logic;
    var control_hazard_pc_next: Addr ;

    always_comb {
        // FIFO に 2 個以上空きがあるとき fetch
        i_membus.valid = if_fifo_wready_two;
        i_membus.addr  = if_pc;
        i_membus.wen   = 0;
        i_membus.wdata = 'x; // no use

        if_fifo_rready = !memu_stall; // memunit が処理中でないとき、FIFO から命令を取り出す
    }

    always_ff {
        if_reset {
            if_pc           = 0;
            if_is_requested = 0;
            if_pc_requested = 0;
        } else {
            if control_hazard {
                if_pc           = control_hazard_pc_next;
                if_is_requested = 0;
            } else {
                if if_is_requested {
                    if i_membus.rvalid {
                        if_is_requested = i_membus.ready && i_membus.valid;
                        if i_membus.ready && i_membus.valid {
                            if_pc           = if_pc_next;
                            if_pc_requested = if_pc;
                        }
                    }
                } else {
                    if i_membus.ready && i_membus.valid {
                        if_is_requested = 1;
                        if_pc           = if_pc_next;
                        if_pc_requested = if_pc;
                    }
                }
            }
        }
    }

    assign control_hazard         = ids_valid && (csru_raise_trap || ids_ctrl.is_jump || inst_is_br(ids_ctrl) && brunit_take);
    assign control_hazard_pc_next = switch {
        csru_raise_trap     : csru_trap_vector, // jump trap_vector when traps
        inst_is_br(ids_ctrl): ids_pc + ids_imm,
        default             : alu_result & ~1
    };

    // ====================================================
    // * Instruction Decoder
    // ====================================================
    let ids_valid    : logic    = if_fifo_rvalid;
    let ids_pc       : Addr     = if_fifo_rdata.addr;
    let ids_inst_bits: Inst     = if_fifo_rdata.bits;
    var ids_is_new   : logic   ; // Whether the instruction was issued in the current clock cycle
    var ids_ctrl     : InstCtrl;
    var ids_imm      : UIntX   ;

    inst decoder: inst_decoder (
        bits: ids_inst_bits,
        ctrl: ids_ctrl     ,
        imm : ids_imm      ,
    );

    always_ff {
        if_reset {
            ids_is_new = 0;
        } else {
            ids_is_new = if if_fifo_rvalid ? if_fifo_rready : 1;
        }
    }

    // ====================================================
    // * Registers
    // ====================================================
    var regfile: UIntX<32>;

    // register number
    let rs1_addr: logic<5> = ids_inst_bits[19:15];
    let rs2_addr: logic<5> = ids_inst_bits[24:20];

    // source register data
    let rs1_data: UIntX = if rs1_addr == 0 ? 0 : regfile[rs1_addr];
    let rs2_data: UIntX = if rs2_addr == 0 ? 0 : regfile[rs2_addr];

    let rd_addr: logic<5> = ids_inst_bits[11:7];
    let wb_data: UIntX    = switch {
        ids_ctrl.is_lui : ids_imm,
        ids_ctrl.is_jump: ids_pc + 4,
        ids_ctrl.is_load: memu_rdata,
        ids_ctrl.is_csr : csru_rdata,
        default         : alu_result,
    };

    always_ff {
        // write back
        if ids_valid && if_fifo_rready && ids_ctrl.rwb_en {
            regfile[rd_addr] = wb_data;
        }
    }

    // ====================================================
    // * ALU
    // ====================================================
    var op1       : UIntX;
    var op2       : UIntX;
    var alu_result: UIntX;

    always_comb {
        case ids_ctrl.itype {
            InstType::R, InstType::B: {
                op1 = rs1_data;
                op2 = rs2_data;
            }
            InstType::I, InstType::S: {
                op1 = rs1_data;
                op2 = ids_imm;
            }
            InstType::U, InstType::J: {
                op1 = ids_pc;
                op2 = ids_imm;
            }
            default: {
                op1 = 'x;
                op2 = 'x;
            }
        }
    }

    inst alum: alu (
        ctrl  : ids_ctrl  ,
        op1               ,
        op2               ,
        result: alu_result,
    );

    // ====================================================
    // * Memory
    // ====================================================
    var memu_rdata: UIntX;
    var memu_stall: logic;

    inst memu: memunit (
        clk               ,
        rst               ,
        valid : ids_valid ,
        is_new: ids_is_new,
        ctrl  : ids_ctrl  ,
        addr  : alu_result,
        rs2   : rs2_data  ,
        rdata : memu_rdata,
        stall : memu_stall,
        membus: d_membus  ,
    );

    // ====================================================
    // * Brunit
    // ====================================================
    var brunit_take: logic;

    inst bru: brunit (
        funct3: ids_ctrl.funct3,
        op1                    ,
        op2                    ,
        take  : brunit_take    ,
    );

    // ====================================================
    // * CSR
    // ====================================================
    var csru_rdata      : UIntX;
    var csru_raise_trap : logic;
    var csru_trap_vector: Addr ;

    inst csru: csrunit (
        clk                           ,
        rst                           ,
        valid   : ids_valid           ,
        pc      : ids_pc              ,
        ctrl    : ids_ctrl            ,
        rd_addr                       ,
        csr_addr: ids_inst_bits[31:20],
        rs1     : if ids_ctrl.funct3[2] == 1 && ids_ctrl.funct3[1:0] != 0 ? {1'b0 repeat XLEN - $bits(rs1_addr), rs1_addr} // expand rs1 with 0
         : rs1_data,
        rdata      : csru_rdata                                                                                                         ,
        raise_trap : csru_raise_trap                                                                                                    ,
        trap_vector: csru_trap_vector                                                                                                   ,
    );

    // ====================================================
    // * Debug
    // ====================================================
    var clock_count: u64;

    always_ff {
        if_reset {
            clock_count = 1;
        } else {
            clock_count += 1;

            if ids_valid {
                $display("# %d", clock_count);
                $display("%h : %h", ids_pc, ids_inst_bits);
                $display("  itype   : %b", ids_ctrl.itype);
                $display("  imm     : %h", ids_imm);
                $display("  rs1[%d] : %h", rs1_addr, rs1_data);
                $display("  rs2[%d] : %h", rs2_addr, rs2_data);
                $display("  op1     : %h", op1);
                $display("  op2     : %h", op2);
                $display("  alu_res : %h", alu_result);
                $display("  mem stall : %b", memu_stall);
                $display("  mem rdata : %h", memu_rdata);
                if if_fifo_rready && ids_ctrl.rwb_en {
                    $display("  reg[%d] <= %h", rd_addr, wb_data);
                }
                if inst_is_br(ids_ctrl) {
                    $display("  br take   : %b", brunit_take);
                }
                if ids_ctrl.is_csr {
                    $display("  csr rdata : %h", csru_rdata);
                    $display("  csr trap  : %b", csru_raise_trap);
                    $display("  csr vec   : %h", csru_trap_vector);
                }
            }
        }
    }
}
