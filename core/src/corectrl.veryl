import eei::*;

package corectrl {
    /// Representing instruction formats
    enum InstType: logic<6> {
        X = 6'b000000,
        R = 6'b000001,
        I = 6'b000010,
        S = 6'b000100,
        B = 6'b001000,
        U = 6'b010000,
        J = 6'b100000,
    }

    /// Struct for flags and used for control
    struct InstCtrl {
        itype    : InstType   , // type of operation
        rwb_en   : logic      , // write registers?
        is_lui   : logic      , // is LUI inst?
        is_aluop : logic      , // use ALU?
        is_muldiv: logic      , // M-extended inst?
        is_op32  : logic      , // OP-32 or OP-IMM-32?
        is_jump  : logic      , // is jump inst?
        is_load  : logic      , // is load inst?
        is_csr   : logic      , // is CSR inst?
        funct3   : logic   <3>, // funct3 field in inst
        funct7   : logic   <7>, // funct7 field in inst
    }

    /// Struct for exceptions
    struct ExceptionInfo {
        valid: logic   ,
        cause: CsrCause,
    }

    /// Determines whether an instruction accesses memory
    function inst_is_memop (
        ctrl: input InstCtrl,
    ) -> logic {
        return ctrl.itype == InstType::S || ctrl.is_load;
    }

    /// Determines whether an instruction is a store operation
    function inst_is_store (
        ctrl: input InstCtrl,
    ) -> logic {
        return inst_is_memop(ctrl) && !ctrl.is_load;
    }

    /// Determines whether the instruction is a branch instruction
    function inst_is_br (
        ctrl: input InstCtrl,
    ) -> logic {
        return ctrl.itype == InstType::B;
    }
}
